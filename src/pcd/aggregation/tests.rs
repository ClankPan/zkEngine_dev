use std::path::PathBuf;

use crate::{
  provider::AggregationEngine,
  run::batched::WasmSNARK,
  traits::zkvm::WasmSNARKTrait,
  utils::logging::init_logger,
  wasm::{
    args::{WASMArgs, WASMArgsBuilder},
    ctx::wasi::WasiWASMCtx,
  },
};

use super::Aggregator;

/// Use Aggregation Engine as backend for proving the SNARK's to be aggregated
type E = AggregationEngine;

#[test]
#[ignore]
fn test_aggregator() -> anyhow::Result<()> {
  init_logger();
  // Config for the computation that is being proved by different nodes and then aggregated
  let args = WASMArgsBuilder::default()
    .file_path(PathBuf::from("wasm/example.wasm"))
    .build();

  // Simulate a network where `num_snarks` SNARKs are generated by different provers
  // and sent to the aggregator
  let num_snarks = 2;
  let snarks = gen_snarks(num_snarks, &args)?;

  // Get public parameters for the SNARKs to be aggregated
  //
  // The Orchestrator Node (ON)/Aggregating node needs to run this to obtain the public
  // parameters for the internal SNARKs, which will then be used as inputs to the verify circuit
  let wasm_pp = WasmSNARK::<E>::setup(&mut WasiWASMCtx::new_from_file(&args)?)?;

  // Get the public params, prover key, verifier key and data needed for aggregation
  tracing::info!("setting up aggregator");
  let (agg_pp, agg_pk, agg_vk, snarks_data) = Aggregator::setup(&wasm_pp, &snarks)?;

  // Start the aggregation process and produce the final SNARK
  let snark = Aggregator::prove(&agg_pp, &agg_pk, &snarks_data)?;

  Ok(snark.verify(&agg_vk)?)
}

#[test]
#[ignore]
fn test_aggregator_single() -> anyhow::Result<()> {
  init_logger();

  let num_snarks = 1;
  let args = WASMArgsBuilder::default()
    .file_path(PathBuf::from("wasm/example.wasm"))
    .build();
  let wasm_pp = WasmSNARK::<E>::setup(&mut WasiWASMCtx::new_from_file(&args)?)?;

  let snarks = gen_snarks(num_snarks, &args)?;
  tracing::info!("setting up aggregator");
  let (pp, pk, vk, snarks_data) = Aggregator::setup(&wasm_pp, &snarks)?;
  let snark = Aggregator::prove(&pp, &pk, &snarks_data)?;

  Ok(snark.verify(&vk)?)
}

fn gen_snarks(num_snarks: usize, args: &WASMArgs) -> anyhow::Result<Vec<WasmSNARK<E>>> {
  let mut snarks = Vec::with_capacity(num_snarks);
  for _ in 0..num_snarks {
    let pp = WasmSNARK::<E>::setup(&mut WasiWASMCtx::new_from_file(args)?)?;

    let (snark, _, _) = WasmSNARK::<E>::prove_wasm(&mut WasiWASMCtx::new_from_file(args)?, &pp)?;

    snarks.push(snark)
  }

  Ok(snarks)
}
